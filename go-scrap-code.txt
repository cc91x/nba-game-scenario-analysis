-- latest progress as of 08-26

package main

/*
 - Go notes here
 - 3 distinct programs / tasks here

 - Odds lookup program
	- input a date as a program argument
	- query odds api with 3 UTC hours ...
		- look up mongoDb for date + utc hr combo, if exists, then don't query,
		- else do query and persist into DB

- Game cleaning program (depends on python game lookup script)
	- double check the raw odds format in Mongo, but once done:
	- clean the data and persist in mongo, as we have. Seems like a simple step

- Odds cleaning program (depends on the above 2)
	- input a date(don't need UTC, can do that on its own)
	- lookup in raw odds in Mongo
	- convert team names to IDs and do mongo lookup for cleaned games
	- for each game where we find a match for existing game, create a cleaned game object

go run test.go is working, so is debug

games to test -
0022300967, 0022300970, 0022300969

*/

import (
	"context"
	"fmt"
	"strconv"
	"strings"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func main() {
	// HitMongo()
	CleanGames("2024-03-18")
}

func HitMongo() {
	// Use the SetServerAPIOptions() method to set the Stable API version to 1
	clientOptions := options.Client().ApplyURI("mongodb://localhost:27017")
	client, err := mongo.Connect(context.TODO(), clientOptions)
	if err != nil {
		panic(err)
	}
	defer func() {
		if err = client.Disconnect(context.TODO()); err != nil {
			panic(err)
		}
	}()

	coll := client.Database("local").Collection("nba-raw-games")
	// Creates a query filter to match documents in which the "name" is
	// "Bagels N Buns"
	filter := bson.D{{"date", "2024-03-18"}}
	// Retrieves the first matching document
	var result bson.M
	err = coll.FindOne(context.TODO(), filter).Decode(&result)

	// This works! thank goodness...
	fmt.Println("Name:", result["away-team-init"])
}

func CleanGames(date string) {
	// dateString := "2024-03-16"

	clientOptions := options.Client().ApplyURI("mongodb://localhost:27017")
	client, err := mongo.Connect(context.TODO(), clientOptions)
	if err != nil {
		panic(err)
	}
	defer func() {
		if err = client.Disconnect(context.TODO()); err != nil {
			panic(err)
		}
	}()

	sourceColl := client.Database("local-nba-project").Collection("nba-raw-games")
	filter := bson.D{{"date", date}}

	teamAbbrevIdMap := fetchTeamIdMap(client.Database("local-nba-project").Collection("nba-team-id-mapping"))
	fmt.Println((len(teamAbbrevIdMap)))
	// var result bson.M
	// var result RawNbaGame
	// err = coll.FindOne(context.TODO(), filter).Decode(&result)
	// fmt.Println("game ID:", result["nba-game-id"])
	// fmt.Println("game ID:", result.Date)

	// Can possibly put this mongoDb call into a helper for brevity
	cursor, err := sourceColl.Find(context.TODO(), filter)
	if err != nil {
		panic(err)
	}
	var results []RawNbaGame

	if err = cursor.All(context.TODO(), &results); err != nil {
		panic(err)
	}

	destColl := client.Database("local-nba-project").Collection("nba-cleaned-game-data")
	var toInsert []interface{}
	for _, result := range results {
		toInsert = append(toInsert, CleanGame(result, teamAbbrevIdMap))

		if err != nil {
			panic(err)
		}
		// fmt.Printf("%s\n", cleanedGame)
	}

	// This has worked
	// result, err := destColl.InsertMany(context.TODO(), []PlayByPlay {})
	fmt.Printf("Documents inserted: %v\n", len(destColl.Name()))
}

// Try throwing an error here...?
func CleanGame(game RawNbaGame, teamIds map[string]string) (cleanedGame CleanedGameFull) {

	splitt := strings.Split("BOS @ MIA", " ")
	fmt.Printf("Documents inserted: %v\n", splitt)
	awayTeam, homeTeam := teamIdsFromMatchup("BOS @ MIA", teamIds)
	startTime, processedPlayByPlay := processPlayByPlay(game)
	return CleanedGameFull{
		GameId:     game.Parameters.GameId,
		Date:       game.Date,
		StartTime:  startTime,           // need a getter for the start time
		AwayTeamId: awayTeam,            // need a function to extract, similar to getHomeAwayPair
		HomeTeamId: homeTeam,            // "
		PlayByPlay: processedPlayByPlay, // make([]PlayByPlay, 0), //create this
		SeasonId:   "seasonId",          // add in the raw game extract - how about an identifier for season type?
	}
}

func processPlayByPlay(game RawNbaGame) (startTime string, playByPlay []PlayByPlay) {
	// assert len here is 2
	var plays bson.A = game.PlayByPlayRows
	fmt.Println(plays)

	prevTimeInterval, awayScore, homeScore := -30, 0, 0

	for _, element := range plays {
		switch play := element.(type) {
		case primitive.A:
			fmt.Println("primitive here")
			// gameId := play[0]
			startTime := play[5]

			// need to define these types - https://go.dev/ref/spec#Type_assertions, this is how to pull fields out of a primitive.A
			clock, score, quarter := play[6].(string), play[10].(string), play[4].(int)
			elapsed := elapsedFromGameClock(clock, quarter)

			// in place of nil - I think strings become ""
			if score != "" {
				awayScore, homeScore = parseScores(score)
			}

			for prevTimeInterval+30 <= elapsed {
				playByPlay = append(playByPlay, PlayByPlay{
					SecondsElapsed: prevTimeInterval + 30,
					AwayScore:      awayScore,
					HomeScore:      homeScore,
				})
				prevTimeInterval += 30
			}

			fmt.Println(score, clock, quarter, startTime)

		default:
			panic("processing error")
		}
	}

	return "abc", playByPlay
}

func parseScores(rawScore string) (awayScore int, homeScore int) {
	split := strings.Split(rawScore, " - ")

	awayScore, err := strconv.Atoi(split[0])
	if err != nil {
		panic(err)
	}

	// why is this not := ..>?
	homeScore, err = strconv.Atoi(split[1])
	if err != nil {
		panic(err)
	}
	return
}

func elapsedFromGameClock(clockTime string, quarter int) (secondsElapsed int) {
	digits := strings.Split(clockTime, ":")

	mins, err := strconv.Atoi(digits[0])
	if err != nil {
		panic(err)
	}
	seconds, err := strconv.Atoi(digits[1])
	if err != nil {
		panic(err)
	}

	elapsedInQuarter := ((11 - mins) * 60) + (60 - seconds)
	prevQuarters := (quarter - 1) * (60 * 12)
	return elapsedInQuarter + prevQuarters

	/*
		mins, seconds = clock.split(":")

		elapsedInQtr = ((11 - int(mins)) * 60) + (60 - int(seconds))
		elapsedInPrevQtrs = (qtr - 1) * (60 * 12)
		return elapsedInQtr + elapsedInPrevQtrs
	*/
}

func fetchTeamIdMap(dbCollection *mongo.Collection) (res map[string]string) {
	cursor, err := dbCollection.Find(context.TODO(), bson.M{})
	if err != nil {
		panic(err)
	}
	// fmt.Println(result)

	var results []TeamIdMapping
	if err = cursor.All(context.TODO(), &results); err != nil {
		panic(err)
	}

	// var res map[string]string
	res = make(map[string]string)
	for _, result := range results {
		res[result.TeamAbbreviaton] = strconv.Itoa(result.TeamId)
	}
	return
}

func teamIdsFromMatchup(matchup string, teamIds map[string]string) (awayTeam string, homeTeam string) {
	dicedMatchup := strings.Split(matchup, " ")

	matchupSymbol := dicedMatchup[1]
	var awayAbbrev, homeAbbrev string
	if matchupSymbol == "@" {
		awayAbbrev, homeAbbrev = dicedMatchup[0], dicedMatchup[2]
	} else {
		awayAbbrev, homeAbbrev = dicedMatchup[2], dicedMatchup[0]
	}

	// pass in mongo db collection here ... or create a map earlier on and pass there, yk what, that's better lets do that
	awayTeam = teamIds[awayAbbrev]
	homeTeam = teamIds[homeAbbrev]
	return
}

// delete this when CleanedGameFull is complete
type CleanedGame struct {
	Value int32
}

/*
- game-id
- game-date
- start-time
- away-team-id
- home-team-id
- playbyplay [
  - time
  - home-score
  - away-score

]
- season-id
*/
type CleanedGameFull struct {
	GameId     string
	Date       string
	StartTime  string
	AwayTeamId string
	HomeTeamId string
	PlayByPlay []PlayByPlay
	SeasonId   string
}

type PlayByPlay struct {
	SecondsElapsed int
	AwayScore      int
	HomeScore      int
}

// These types will work for loading the game data
type RawNbaGame struct {
	Resource       string     `bson:"resource"`
	Parameters     Parameters `bson:"parameters"`
	PlayByPlayRows bson.A     `bson:"raw-play-by-play"` // should this just be a bson?
	Date           string     `bson:"date"`
	Matchup        string     `bson:"matchup"` // this should be "Bos vs Mia", copied from the season data script
}

type Parameters struct {
	GameId     string `bson:"GameID"`
	StarPeriod int32  `bson:"StartPeriod"`
	EndPeriod  int32  `bson:"EndPeriod"`
}

type ResultSet struct {
	Name    string          `bson:"name"`
	Headers []string        `bson:"headers"`
	RowSet  [][]interface{} `bson:"rowSet"`
}

type TeamIdMapping struct {
	TeamId          int    `bson:"team-id"`
	TeamName        string `bson:"team-name"`
	TeamAbbreviaton string `bson:"team-abbreviation"`
}
